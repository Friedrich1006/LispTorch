(define t_is_tensor (lambda (obj) (_torch_is_tensor obj)))
(define t_numel (lambda (input) (_torch_numel input)))
(define t_tensor (lambda (data dtype:#n device:#n requires_grad:#f pin_memory:#f) (_torch_tensor data dtype device requires_grad pin_memory)))
(define t_as_tensor (lambda (data dtype:#n device:#n) (_torch_as_tensor data dtype device)))
(define t_from_numpy (lambda (ndarray) (_torch_from_numpy ndarray)))
(define t_zeros (lambda (*sizes out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_zeros *sizes out dtype layout device requires_grad)))
(define t_ones (lambda (*sizes out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_ones *sizes out dtype layout device requires_grad)))
(define t_arange (lambda (start:0 end step:1 out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_arange start end step out dtype layout device requires_grad)))
(define t_range (lambda (start:0 end step:1 out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_range start end step out dtype layout device requires_grad)))
(define t_eye (lambda (n m:#n out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_eye n m out dtype layout device requires_grad)))
(define t_empty (lambda (*sizes out:#n dtype:#n layout:t_strided device:#n requires_grad:#f pin_memory:#f) (_torch_empty *sizes out dtype layout device requires_grad pin_memory)))
(define t_full (lambda (size fill_value out:#n dtype:#n layout:t_strided device:#n requires_grad:#f) (_torch_full size fill_value out dtype layout device requires_grad)))
(define t_cat (lambda (tensors dim:0 out:#n) (_torch_cat tensors dim out)))
